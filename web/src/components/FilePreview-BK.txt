const FilePreview: React.FC<IFilePreview> = ({ fileInfo }) => {
    const [fileType, setFileType] = useState<string>("");
    const [fileURL, setFileURL] = useState<string>("");
    const [textContent, setTextContent] = useState<string>("");
    const [isLoading, setIsLoading] = useState<boolean>(true);
    const [isMobile, setIsMobile] = useState<boolean>(false);
    const [pdfBlob, setPdfBlob] = useState<Blob | null>(null);
    const { session } = useStore(appStore);
    const pdfCanvasRef = useRef<HTMLCanvasElement>(null);

    // Detect mobile devices on component mount
    useEffect(() => {
        const checkIfMobile = () => {
            const userAgent = navigator.userAgent || navigator.vendor || (window as any).opera;
            const mobileRegex = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i;
            setIsMobile(mobileRegex.test(userAgent.toLowerCase()));
        };
        
        checkIfMobile();
        
        // Also check on resize in case of orientation change
        window.addEventListener('resize', checkIfMobile);
        return () => window.removeEventListener('resize', checkIfMobile);
    }, []);

    useEffect(() => {
        const fetchFile = async () => {
            setIsLoading(true);
            try {
                const fileContentUrl: string = fileInfo.fileContent as string
                console.log("File content url: ", fileContentUrl)

                let actualUrlToFetch = fileContentUrl

                console.log(`== Data before ${actualUrlToFetch}`)
                if(actualUrlToFetch.includes("inblock.io")){
                    
                    actualUrlToFetch = actualUrlToFetch.replace("http", "https")
                }
                console.log(`== Data after ${actualUrlToFetch}`)

                const response = await fetch(actualUrlToFetch, {
                    headers: {
                        nonce: `${session?.nonce}`
                    }
                });
                if (!response.ok) throw new Error("Failed to fetch file");

                // Get MIME type from headers
                let contentType = response.headers.get("Content-Type") || "";
                console.log("Original Content-Type from headers:", contentType);

                // Clone the response for potential text extraction
                const responseClone = response.clone();
                
                // Get the raw data as ArrayBuffer first
                const arrayBuffer = await response.arrayBuffer();
                console.log("ArrayBuffer size:", arrayBuffer.byteLength);
                
                // If content type is missing or generic, try to detect it
                if (contentType === "application/octet-stream" || contentType === "") {
                    const uint8Array = new Uint8Array(arrayBuffer);
                    contentType = detectFileType(uint8Array);
                    console.log("Detected file type:", contentType);
                }
                
                // For PDF files, ensure proper content type
                if (contentType === "application/pdf" || 
                    (fileInfo.fileName && fileInfo.fileName.toLowerCase().endsWith(".pdf"))) {
                    contentType = "application/pdf";
                    
                    // Store PDF blob for direct rendering if needed
                    const pdfBlob = new Blob([arrayBuffer], { type: "application/pdf" });
                    setPdfBlob(pdfBlob);
                }
                
                // Handle audio files
                if (contentType.startsWith("audio/") || 
                    (fileInfo.fileName && (/\.(mp3|wav|ogg|aac|flac|m4a)$/i).test(fileInfo.fileName))) {
                    if (!contentType.startsWith("audio/")) {
                        // Set a default audio MIME type if needed
                        contentType = "audio/mpeg";
                    }
                }
                
                // Handle video files
                if (contentType.startsWith("video/") || 
                    (fileInfo.fileName && (/\.(mp4|webm|ogg|mov|avi|wmv|flv|mkv)$/i).test(fileInfo.fileName))) {
                    if (!contentType.startsWith("video/")) {
                        // Set a default video MIME type if needed
                        contentType = "video/mp4";
                    }
                }
                
                // Handle text-based content types
                if (contentType.startsWith("text/") || 
                    contentType === "application/json" ||
                    contentType === "application/xml" ||
                    contentType === "application/javascript") {
                    try {
                        const text = await responseClone.text();
                        setTextContent(text);
                    } catch (error) {
                        console.error("Error reading text content:", error);
                        // Try decoding the array buffer as UTF-8 text as fallback
                        try {
                            const decoder = new TextDecoder("utf-8");
                            const text = decoder.decode(arrayBuffer);
                            setTextContent(text);
                        } catch (decodeError) {
                            console.error("Error decoding text content:", decodeError);
                        }
                    }
                }
                
                // Create a proper blob with the correct content type
                const blob = new Blob([arrayBuffer], { type: contentType });
                console.log("Created blob with type:", contentType, "size:", blob.size);
                
                setFileType(contentType);
                console.log("Final content type set to:", contentType);
                
                // Create URL from the properly typed blob
                const objectURL = URL.createObjectURL(blob);
                console.log("Object URL created:", objectURL);
                setFileURL(objectURL);
            } catch (error) {
                console.error("Error fetching file:", error);
            } finally {
                setIsLoading(false);
            }
        };

        fetchFile();

        return () => {
            if (fileURL) URL.revokeObjectURL(fileURL);
        };
    }, [fileInfo.fileContent, session?.nonce]);

    // Effect to render first page of PDF for mobile
    useEffect(() => {
        const renderPdfFirstPage = async () => {
            if (fileType === "application/pdf" && isMobile && pdfBlob && pdfCanvasRef.current) {
                try {
                    // Load the PDF.js library dynamically
                    // This assumes you've added PDF.js to your project or are loading it from CDN
                    // You'll need to add this script to your HTML or bundle:
                    // <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
                    const pdfjsLib = window['pdfjs-dist/build/pdf'];
                    
                    if (!pdfjsLib) {
                        console.error("PDF.js library not found");
                        return;
                    }
                    
                    // Load the PDF document
                    const loadingTask = pdfjsLib.getDocument(fileURL);
                    const pdf = await loadingTask.promise;
                    
                    // Get the first page
                    const page = await pdf.getPage(1);
                    
                    // Set up canvas for rendering
                    const canvas = pdfCanvasRef.current;
                    const context = canvas.getContext('2d');
                    
                    // Calculate scale to fit width
                    const viewport = page.getViewport({ scale: 1 });
                    const containerWidth = canvas.parentElement?.clientWidth || window.innerWidth;
                    const scale = containerWidth / viewport.width;
                    const scaledViewport = page.getViewport({ scale });
                    
                    // Set canvas dimensions
                    canvas.height = scaledViewport.height;
                    canvas.width = scaledViewport.width;
                    
                    // Clear any previous content with transparent background
                    context?.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Render the page
                    const renderContext = {
                        canvasContext: context,
                        viewport: scaledViewport,
                        background: 'transparent'
                    };
                    
                    await page.render(renderContext).promise;
                    console.log("PDF first page rendered successfully");
                    
                } catch (error) {
                    console.error("Error rendering PDF first page:", error);
                }
            }
        };
        
        if (isLoading === false) {
            renderPdfFirstPage();
        }
    }, [fileType, isMobile, pdfBlob, isLoading, fileURL]);

    if (isLoading) return <p>Loading...</p>;

    console.log("Rendering file with type:", fileType, "Mobile:", isMobile);
    
    // Render based on file type
    if (fileType.startsWith("image/")) {
        return <img src={fileURL} alt="Fetched file" style={{ maxWidth: "100%", height: "auto" }} />;
    }

    if (fileType === "application/pdf") {
        // Mobile-friendly approach for PDF viewing with thumbnail fallback
        if (isMobile) {
            return (
                <div style={{ width: "100%", backgroundColor: "transparent" }}>
                    {/* Canvas for rendering the first page preview */}
                    <div style={{ 
                        width: "100%", 
                        marginBottom: "10px", 
                        textAlign: "center",
                        backgroundColor: "transparent"
                    }}>
                        <canvas 
                            ref={pdfCanvasRef} 
                            style={{ 
                                width: "100%", 
                                maxWidth: "100%", 
                                height: "auto",
                                backgroundColor: "transparent",
                                display: "block", // Removes any potential spacing
                                margin: "0 auto" // Centers the canvas
                            }}
                        />
                    </div>
                    
                    {/* Fallback iframe (might work on some mobile browsers) */}
                    <div style={{ width: "100%", height: "400px", backgroundColor: "transparent" }}>
                        <iframe
                            src={fileURL}
                            title="PDF Viewer"
                            width="100%"
                            height="100%"
                            style={{ border: "none" }}
                        >
                            <p>Unable to display PDF file.</p>
                        </iframe>
                    </div>
                    
                    {/* Download link as another fallback option */}
                    <div style={{ marginTop: "15px", textAlign: "center" }}>
                        <a 
                            href={fileURL} 
                            download={fileInfo.fileName || "document.pdf"} 
                            style={{ 
                                color: "#fff", 
                                backgroundColor: "#4285f4", 
                                padding: "10px 15px", 
                                borderRadius: "4px", 
                                textDecoration: "none",
                                display: "inline-block"
                            }}
                        >
                            Download PDF
                        </a>
                    </div>
                </div>
            );
        } else {
            // Original desktop approach
            return (
                <object
                    data={fileURL}
                    type="application/pdf"
                    width="100%"
                    height="600px"
                    style={{ border: "none" }}
                >
                    <p>Unable to display PDF file. <a href={fileURL} target="_blank" rel="noopener noreferrer">Download</a> instead.</p>
                </object>
            );
        }
    }

    if (fileType.startsWith("text/") || 
        fileType === "application/json" || 
        fileType === "application/xml" || 
        fileType === "application/javascript") {
        return (
            <div style={{
                whiteSpace: "pre-wrap",  // Preserves spaces and line breaks
                wordBreak: "break-word",  // Prevents overflow on long words
                fontFamily: "monospace",
                padding: "10px",
                border: "1px solid #ccc",
                borderRadius: "4px",
                maxHeight: "600px",
                overflow: "auto"
            }}>
                {textContent}
            </div>
        );
    }

    if (fileType.startsWith("audio/")) {
        return (
            <div>
                <audio controls style={{ width: "100%" }}>
                    <source src={fileURL} type={fileType} />
                    Your browser does not support the audio element.
                </audio>
                <div style={{ marginTop: "10px" }}>
                    <a href={fileURL} download={fileInfo.fileName || "audio"} style={{ color: "blue", textDecoration: "underline" }}>
                        Download audio file
                    </a>
                </div>
            </div>
        );
    }

    if (fileType.startsWith("video/")) {
        return (
            <div>
                <video controls style={{ maxWidth: "100%", height: "auto", backgroundColor: "#000" }}>
                    <source src={fileURL} type={fileType} />
                    Your browser does not support the video element.
                </video>
                <div style={{ marginTop: "10px" }}>
                    <a href={fileURL} download={fileInfo.fileName || "video"} style={{ color: "blue", textDecoration: "underline" }}>
                        Download video file
                    </a>
                </div>
            </div>
        );
    }

    // Default download option for other file types
    return (
        <a href={fileURL} download className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
            Download File
        </a>
    );
};